// rules/index.js

// 1. Import rule classes (adjust paths/names to your actual files)
import { Majority } from "./Majority.js";
import { MajorityDiagonal } from "./MajorityDiagonal.js";
import { MajorityStickyBorders } from "./MajorityStickyBorders.js";
import { MajorityStrongConsensus } from "./MajorityStrongConsensus.js";

import { RPS } from "./RPS.js";
import { RPS4 } from "./RPS4.js";
import { RPS5 } from "./RPS5.js";
import { RPS6 } from "./RPS6.js";
import { RPSCascade } from "./RPSCascade.js";

import { GeneticDrift } from "./GeneticDrift.js";
import { GeneticDriftLocalBattle } from "./GeneticDriftLocalBattle.js";
import { GeneticDriftGlobalBattle } from "./GeneticDriftGlobalBattle.js";

import { ImaginaryGroupBase } from "./ImaginaryGroupBase.js";
import { ImaginaryGroupSingle } from "./ImaginaryGroupSingle.js";
import { ImaginaryGroupQuadrants } from "./ImaginaryGroupQuadrants.js";

import { QuaternionGroup } from "./QuaternionGroup.js";
import { QuaternionGroupPizza } from "./QuaternionGroupPizza.js";
import { QuaternionGroupSpiral } from "./QuaternionGroupSpiral.js";

import { C4Group } from "./C4Group.js";
import { Dihedral3Group } from "./Dihedral3Group.js";
import { Dihedral4Group } from "./Dihedral4Group.js";
import { Dihedral6Group } from "./Dihedral6Group.js";

import { ElementaryAbelian_2_2_2_Group } from "./ElementaryAbelian_2_2_2_Group.js";

// 2. RULES: id -> factory
export const RULES = {
  majority: (config) => new Majority(config),
  "majority-diagonal": () => new MajorityDiagonal({}),
  "majority-sticky-borders": () => new MajorityStickyBorders(),
  "majority-strong-consensus": () => new MajorityStrongConsensus(),

  rps3: () => new RPS(),
  rps4: () => new RPS4(),
  rps5: () => new RPS5(),
  rps6: () => new RPS6(),
  rpsCascade: () => new RPSCascade(),

  "genetic-drift": () => new GeneticDrift(),
  "genetic-drift-local": () => new GeneticDriftLocalBattle(),
  "genetic-drift-global": () => new GeneticDriftGlobalBattle(),

  "imaginary-base": () => new ImaginaryGroupBase(),
  "imaginary-single": () => new ImaginaryGroupSingle(),
  "imaginary-quadrants": () => new ImaginaryGroupQuadrants(),

  quaternion: () => new QuaternionGroup(),
  "quaternion-pizza": () => new QuaternionGroupPizza(),
  "quaternion-spiral": () => new QuaternionGroupSpiral(),

  c4: () => new C4Group(),
  d3: () => new Dihedral3Group(),
  d4: () => new Dihedral4Group(),
  d6: () => new Dihedral6Group(),
  "elem-abelian-2-2-2": () => new ElementaryAbelian_2_2_2_Group(),
};

// 3. RULE_META: id -> label/description
export const RULE_META = {
  majority: {
    label: "Majority",
    description:
      "Cells adopt the locally dominant colour when it has a clear lead: classic clustering.",
  },
  "majority-diagonal": {
    label: "Majority (Diagonal)",
    description:
      "Majority using only diagonal neighbours, giving X-shaped and rotated domains.",
  },
  "majority-sticky-borders": {
    label: "Majority – Sticky Borders",
    description:
      "Interfaces resist flipping, preserving sharp boundaries between regions.",
  },
  "majority-strong-consensus": {
    label: "Majority – Strong Consensus",
    description:
      "Requires a strong local lead to change; slower, more blocky consensus.",
  },

  rps3: {
    label: "RPS (3-state)",
    description:
      "Classic cyclic dominance; neighbours weighted by who beats whom.",
  },
  rps4: {
    label: "RPS (4-state)",
    description: "Four-state cyclic dominance with extended interaction loop.",
  },
  rps5: {
    label: "RPS (5-state)",
    description: "Five-state cycle; dense interference and swirling domains.",
  },
  rps6: {
    label: "RPS (6-state)",
    description: "Six-state cycle; rich, slow-mixing wave structures.",
  },
  rpsCascade: {
    label: "RPS Cascade",
    description:
      "Cyclic dominance with cascading predator influence; multi-level interactions.",
  },
  "genetic-drift": {
    label: "Genetic Drift (Global)",
    description:
      "Each cell samples from global colour frequencies: pure drift.",
  },
  "genetic-drift-local": {
    label: "Genetic Drift (Local)",
    description:
      "Cells resample from their immediate neighbours: patchy local drift.",
  },
  "genetic-drift-global": {
    label: "Genetic Drift (Local × Global)",
    description:
      "Local choices biased by global popularity: rich feedback dynamics.",
  },

  "imaginary-base": {
    label: "Imaginary Group Base",
    description:
      "Cells store ±1, ±i; updates multiply neighbours according to complex-unit rules.",
  },
  "imaginary-single": {
    label: "Imaginary Group (Single Source)",
    description: "Imaginary dynamics from a single seeded region.",
  },
  "imaginary-quadrants": {
    label: "Imaginary Group (Quadrants)",
    description:
      "Quadrants seeded with different units; interfaces show their interactions.",
  },

  quaternion: {
    label: "Quaternion Group",
    description:
      "Cells multiply neighbours in Q8; non-commutative group dynamics.",
  },
  "quaternion-pizza": {
    label: "Quaternion Group (Pizza)",
    description: "Quaternion dynamics from radial sector initialisation.",
  },
  "quaternion-spiral": {
    label: "Quaternion Group (Spiral)",
    description: "Quaternion rule from spiral seed; twisting structure.",
  },

  c3: {
    label: "C3 (Z/3)",
    description:
      "Additive mod 3: neighbours summed modulo 3; simple wave patterns.",
  },
  d3: {
    label: "D₃ (triangle symmetries)",
    description:
      "Products in dihedral group of order 6; triangular symmetry themes.",
  },
  d4: {
    label: "D₄ (square symmetries)",
    description:
      "Products in D4; grid-aligned, reflection/rotation-driven patterns.",
  },
  d6: {
    label: "D₆ (hexagon symmetries)",
    description: "Dihedral group of order 12; more complex symmetric tilings.",
  },
  "elem-abelian-2-2-2": {
    label: "(Z/2)³",
    description:
      "XOR-based rule on 3-bit vectors; crisp, high-frequency interference.",
  },
};

// 4. Keys + helper

export const RULE_KEYS = Object.keys(RULES);

export function getRuleById(id, config = {}) {
  const factory = RULES[id];
  if (!factory) {
    throw new Error(`[Rules] Unknown rule id: ${id}`);
  }

  return factory(config);
}
